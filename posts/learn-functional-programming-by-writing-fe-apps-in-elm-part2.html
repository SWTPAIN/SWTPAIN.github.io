<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta property="og:site_name" content="KaFai Choi">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Learn functional programming by writing FE apps in Elm (pt.2)">
    <meta property="og:image" content>
    <meta property="og:url" content="https://bruteforcecat.github.io/posts/learn-functional-programming-by-writing-fe-apps-in-elm-part2.html">
    <meta property="og:description" content="Learn functional programming by writing FE apps in Elm (pt.2)">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="KaFai Choi">
    <meta name="description" content="Learn functional programming by writing FE apps in Elm (pt.2)">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="../css/default.css">
    <link rel="stylesheet" type="text/css" href="../css/pandoc.css">
    <link rel="alternate" type="application/rss+xml" href="../rss.xml" title="RSS">
    <script>try{Typekit.load({ async: true });}catch(e){}</script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js"></script>
    <title>Learn functional programming by writing FE apps in Elm (pt.2)</title>
  </head>
  <body>
    <nav class="navigation">
      <ul class="navigation__list">
        <li class="navigation__item">
          <a class="header__link" href="../">
            Y = λf.(λx.f(xx))(λx.f(xx))
          </a>
        </li>
      </ul>
    </nav>
    
    <article>
  <div class="article__infoContainer">
    <div class="article__info">
      <p class="article__title">
         Learn functional programming by writing FE apps in Elm (pt.2)
      </p>
      <time class="article__date">July 23, 2017</time>
    </div>
  </div>
  <div class="article__content">
    <h2 id="quizwizard-quiz-list">QuizWizard &amp; Quiz List</h2>
<p>In part 2, we can create quiz and see list of quizzes in our app. Instead of a walkthrough of coding, it will be highlights and explanations about some key changes we made. It’s recommended to read the source code and play around with the apps before reading it.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="fu">git</span> clone git@github.com:bruteforcecat/quiz-maker.git
<span class="fu">git</span> checkout v0.0.2</code></pre></div>
<p><br /></p>
<h2 id="new-folder-structure">New Folder Structure</h2>
<pre class="elm"><code>-- new folder structure
-- |- elm
--     |- Main.elm
--     |- Model
--        |- Quiz.elm
--        |- Shared.elm
--     |- Model.elm
--     |- QuizWizard
--        |- Model.elm
--        |- Update.elm
--        |- View.elm
--     |- Update
--        |- Utils.elm
--     |- Update.elm
--     |- View.elm</code></pre>
<p>We have separated <code>update</code>, <code>view</code>, <code>Model</code> into its own module. And notice there is a folder <code>QuizWizard</code> which contain <code>Model.elm</code>, <code>Update.elm</code>, <code>View.elm</code>. Unlike React or most other JS framework, there are no reusable components in Elm but only reusable functions. And by keeping pure function, we can avoid using internal state in component.</p>
<p><br /></p>
<h2 id="use-html.program-instead-html.beginnerprogram">Use Html.program instead Html.beginnerProgram</h2>
<pre class="elm"><code>-- Main.elm
main : Program Never Model Msg
main =
    Html.program
        { init = Update.init
        , view = View.view
        , update = Update.update
        , subscriptions = Update.subscriptions
        }
</code></pre>
<p>We can ignore <code>subscriptions</code> function for now. The main difference is the <code>update</code> function return a tuple of <code>Model</code> and <code>Cmd Msg</code>. A command is a description of an effect that Elm Runtime help us to perform so our code can stay pure in Elm.</p>
<p><br /></p>
<h2 id="thinking-in-model">Thinking in Model</h2>
<p>Because of being the state of the whole application, it is very common to think about data structure in <code>Model</code> before we make any change.</p>
<pre class="elm"><code>-- Model.elm
module Model exposing (..)

import QuizWizard.Model as QuizWizardModel

type alias Model =
    { quizzes : List Quiz
    , quizWizard : QuizWizardModel.Model
    , notification : Maybe String
    }

-- QuizWizard/Model.elm
module QuizWizard.Model exposing (..)

type alias Model =
    { title :
        String
    , questions : List Question
    , currentQuestionField :
        QuestionField
    , error : Maybe Error
    , currentStep : Step
    }

type alias QuestionField =
    { title : String
    , correctAnswer : String
    , prevWrongAnswers : List String
    , lastWrongAnswer : String
    }

-- Model/Quiz.elm
module Model.Quiz exposing (..)


type alias Quiz =
    { title : String
    , questions : List Question
    }


type alias Question =
    { title : String
    , correctAnswer : String
    , wrongAnswers : List String
    }</code></pre>
<p>The model type is record coding field <code>quizzes</code>, <code>quizWizard</code> and <code>notification</code> which explicitly define our data and we can also easily know what this application does just by reading the <code>Model</code> type.</p>
<p><br /></p>
<h2 id="impossible-state">Impossible State</h2>
<p>Let’s look at the <code>QuestionField</code> which is a Record with title, correctAnswer, prevWrongAnswers and lastWrongAnswer. You might wonder why don’t we just simplify it to as following:</p>
<pre class="elm"><code>type alias QuestionField =
    { title : String
    , correctAnswer : String
    , wrongAnswers : List String
    }</code></pre>
<p>If we simplify the QuestionField type as this, what if we see the questionField as the following during our runtime?</p>
<pre class="elm"><code>questionField = {
  title = &quot;Question 1&quot;
  , correctAnswer : &quot;Correct Answer&quot;
  , wrongAnswers : []
}</code></pre>
<p>This is not what we want because we want the <code>wrongAnswers</code> to have at least one element. And if we explicitly saprate the <code>lastWrongAnswer</code> as its own field, we can guarantee there will be at least one element without the need in writing defensive code which also save us from writing unnecessary test.</p>
<p><br /></p>
<h2 id="changing-applicaiton-state">Changing Applicaiton State</h2>
<pre class="elm"><code>-- QuizWizard/Model.elm

type Msg
    = UpdateQuizTitle String
    | UpdateCurrentQuestionFieldMsg UpdateCurrentQuestionFieldMsg
    | StartAddQuestion
    | AddCurrentQuestion
    | CreateQuizRequest
    | CreateQuiz Quiz
    | BackStep


type UpdateCurrentQuestionFieldMsg
    = UpdateCurrentQuetionTitle String
    | UpdateCurrentQuestionCorrectAnswer String
    | UpdateCurrentQuestionPrevWrongAnswer Int String
    | UpdateCurrentQuestionLastWrongAnswer String
    | AddOneWrongQuestion</code></pre>
<p>We define all the possible action or event that can happen in <code>Msg</code> Type. These messages usually come from user’ interaction(Dom event), external source like websocket or runtime’s response for command.</p>
<p>Note that we group current question field into its own sum Union type so we can have a separate function to handle it and avoid a crazily long pattern matching in update function.</p>
<pre class="elm"><code>-- QuizWizard/Update.elm
update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        UpdateQuizTitle title -&gt;
            ( { model
                | title = title
              }
            , Cmd.none
            )

        UpdateCurrentQuestionFieldMsg updateCurrentQuestionFieldMsg -&gt;
            ( { model
                | currentQuestionField = updateCurrentQuestionField updateCurrentQuestionFieldMsg model.currentQuestionField
              }
            , Cmd.none
            )

updateCurrentQuestionField : UpdateCurrentQuestionFieldMsg -&gt; QuestionField -&gt; QuestionField
updateCurrentQuestionField updateCurrentQuestionFieldMsg
  case updateCurrentQuestionFieldMsg of
      UpdateCurrentQuetionTitle title -&gt;
          { questionField
              | title = title
          }
    -- ...
 questionField =</code></pre>
<p>Here, we can also see one of the advantage of ADT over classes is the easiness of adding a new operation on a new member in a type. No other function in update has to be changed if we modify only the function applying on one member of sum Union Type.</p>
<p><br /></p>
<h2 id="views-is-just-purely-functions">Views is just purely functions</h2>
<pre class="elm"><code>-- QuizWizard/View.elm
view : Model -&gt; Html Msg
view model =
    div [ class &quot;panel&quot; ]
        [ div [ class &quot;panel-heading&quot; ] [ text &quot;Create your own quiz&quot; ]
        , div [ class &quot;panel-block&quot; ]
            [ div [ class &quot;section&quot; ]
                [ div [ class &quot;title&quot; ] [ p [] [ model |&gt; title |&gt; text ] ]
                , div []
                    [ notification model
                    , form model
                    ]
                , footer model
                ]
            ]
        ]

notification : Model -&gt; Html Msg
notification { error } =
    case error of
        Nothing -&gt;
            div [] []

        Just error_ -&gt;
            div [ class &quot;notification is-danger&quot; ]
                [ text error_
                ]

form : Model -&gt; Html Msg
form { title, currentQuestionField, currentStep } =
    let
        formContent =
            case currentStep of
                AddTitle -&gt;
                    quizTitleForm title

                AddQuestion -&gt;
                    quizQuestionForm currentQuestionField |&gt; Html.map UpdateCurrentQuestionFieldMsg
    in
        Html.form []
            [ formContent
            ]

quizTitleForm : String -&gt; Html Msg
quizTitleForm title =
    div [ class &quot;field&quot; ]
        [ div [ class &quot;control&quot; ]
            [ input
                [ class &quot;input&quot;
                , type_ &quot;text&quot;
                , placeholder &quot;Quiz Title&quot;
                , onInput UpdateQuizTitle
                , value title
                ]
                []
            ]
        ]
</code></pre>
<p>Because view is just elm function, you can compose them by applying other view function. And it’s generally good practice to only require minimal argument in view function instead of the whole <code>Model</code> and so we can scale the application easily in the future.</p>
<p><br /></p>
<h2 id="child-parent-communication">Child-parent communication</h2>
<p>In our quiz-maker application, when the user click create in quiz wizard, we will need to add the quiz into our list. However, it cannot be done in <code>QuizWizard.Update</code> because the <code>quizzes</code> field belongs in the <code>Model</code> in <code>main.elm</code>. And this is the time that the parent need to respond to some event happen inside the children. There are three ways to do that in elm which are NoMap, OutMsg and Translator.</p>
<p>And in pt2, we will only use the most naive and intuitive way to handle child-parent communication.</p>
<pre class="elm"><code>-- Update.elm
update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        QuizWizardMsg quizWizardMsg -&gt;
            case quizWizardMsg of
                QuizWizardModel.CreateQuiz quiz -&gt;
                    ( { model
                        | quizWizard = QuizWizardModel.initialModel
                        , quizzes = quiz :: model.quizzes
                        , notification = Just &quot;Your quiz is created&quot;
                      }
                    , Cmd.none
                    )

                _ -&gt;
                    let
                        ( quizWizard, cmd ) =
                            QuizWizardUpdate.update quizWizardMsg model.quizWizard
                    in
                        ( { model
                            | quizWizard = quizWizard
                          }
                        , Cmd.map QuizWizardMsg cmd
                        )</code></pre>
<p>So the update function in <code>Main.elm</code> will pattern match the msg <code>QuizWizardModel.CreateQuiz</code> and response to it instead of delegating the message to update function in <code>QuizWizard.Update</code>. We will discuss the other better three approach later in the series.</p>
<p><br /></p>
<h2 id="higher-kinded-types">Higher-kinded types</h2>
<p>There will be validation checking when use try to add new question to the quiz. If some question is empty, a error notification will be shown.</p>
<pre class="elm"><code>update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    case msg of
      -- ....
      AddCurrentQuestion -&gt;
          case getCurrentQuestion model.currentQuestionField of
              Err err -&gt;
                  { model | error = Just err } ! [ Cmd.none ]

              Ok question -&gt;
                  { model
                      | questions = model.questions ++ [ question ]
                      , currentQuestionField = defaultQuestionField
                      , error = Nothing
                  }
                      ! [ Cmd.none ]



getCurrentQuestion : QuestionField -&gt; Result Error Question
getCurrentQuestion ({ title, correctAnswer, prevWrongAnswers, lastWrongAnswer } as questionField) =
  Result.map3
      (\title correctAnswer wrongAnswers -&gt;
          { title = title
          , correctAnswer = correctAnswer
          , wrongAnswers = wrongAnswers
          }
      )
      (if title == &quot;&quot; then
          Err &quot;Question Title cannnot be empty&quot;
       else
          Ok title
      )
      (if correctAnswer == &quot;&quot; then
          Err &quot;Correct Answer cannot be empty&quot;
       else
          Ok correctAnswer
      )
      (getWrongAnswers questionField)

-- using map3 instead of nested pattern matching
-- case title of
--     &quot;&quot; -&gt;
--         Err &quot;Question Title cannot be empty&quot;
--
--     title_ -&gt;
--         case correctAnswer of
--             &quot;&quot; -&gt;
--                 Err &quot;Correct Answer cannot be empty&quot;
--
--             correctAnswer_ -&gt;
--                 case getWrongAnswers questionField of
--                     Err err_ -&gt;
--                         Err err_
--
--                     Ok wrongAnswers -&gt;
--                         Ok
--                             { title = title_
--                             , correctAnswer = correctAnswer_
--                             , wrongAnswers = wrongAnswers
--                             }
</code></pre>
<p><code>Result</code> is a type constructor that take two types. Here the return type of <code>getCurrentQuestion</code> is <code>Result Error Question</code> which means the value of that type might be either <code>Error</code> or <code>Question</code>. So now the caller have to handle both error and success case when we try to apply this function. And the difference of <code>Either</code> and <code>Maybe</code> is we can pass the error info instead of <code>Nothing</code>.</p>
<p>We use <code>Result.map3</code> here by turning title and correctAnswer to Result type. So we can avoid three level nested pattern matching which might be hard to read.</p>
<p>And that’s all for the part two. In the next part, we will actually save the data to firebase and create a sharable link for user to give the quiz to friends. <br /></p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/870919/why-are-haskell-algebraic-data-types-closed">why-are-haskell-algebraic-data-types-closed</a></li>
<li><a href="https://www.youtube.com/watch?v=IcgmSRJHu_8">Make impossible state impossible</a></li>
</ul>
  </div>
  
  <hr>
  <div class="disqus__block">
  <div id="disqus_thread"></div>
  <script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = 'https://swtpain.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

  
</article>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-102897942-1', 'auto');
      ga('send', 'pageview');

    </script>
    <script id="dsq-count-scr" src="//swtpain.disqus.com/count.js" async></script>
</html>
