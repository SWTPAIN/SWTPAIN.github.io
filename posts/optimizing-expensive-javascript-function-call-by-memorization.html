<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta property="og:site_name" content="KaFai Choi">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Optimizing Expensive Javascript Function Application by Memorization">
    <meta property="og:image" content>
    <meta property="og:url" content="https://bruteforcecat.github.io/posts/optimizing-expensive-javascript-function-call-by-memorization.html">
    <meta property="og:description" content="Optimizing Expensive Javascript Function Application by Memorization">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="KaFai Choi">
    <meta name="description" content="Optimizing Expensive Javascript Function Application by Memorization">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="../css/default.css">
    <link rel="stylesheet" type="text/css" href="../css/pandoc.css">
    <link rel="alternate" type="application/rss+xml" href="../rss.xml" title="RSS">
    <script>try{Typekit.load({ async: true });}catch(e){}</script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js"></script>
    <title>Optimizing Expensive Javascript Function Application by Memorization</title>
  </head>
  <body>
    <nav class="navigation">
      <ul class="navigation__list">
        <li class="navigation__item">
          <a class="header__link" href="../">
            Y = λf.(λx.f(xx))(λx.f(xx))
          </a>
        </li>
      </ul>
    </nav>
    
    <article>
  <div class="article__infoContainer">
    <div class="article__info">
      <p class="article__title">
         Optimizing Expensive Javascript Function Application by Memorization
      </p>
      <time class="article__date">March  2, 2016</time>
    </div>
  </div>
  <div class="article__content">
    <p>There will be some occasion that you have some function that takes long processing time. And if the function is pure (no side-effect), we can use a simple technique called memoization to speed it up. The rational is basically creating a cache lookup table mapping arguments to result in order to avoid repeating the calculation of results for previously processed inputs.</p>
<p>Consider a naive implementation of fibonacci function.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> fibonacci <span class="op">=</span> n <span class="op">=&gt;</span>
  n <span class="op">&lt;</span> <span class="dv">2</span>
    <span class="op">?</span> n
    : <span class="at">fibonacci</span>(n<span class="op">-</span><span class="dv">2</span>) <span class="op">+</span> <span class="at">fibonacci</span>(n<span class="op">-</span><span class="dv">1</span>)<span class="op">;</span></code></pre></div>
<p>It will takes so long because of repeated calculation.</p>
<p>One simple memoized function is as follow.</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> memoized <span class="op">=</span> fn <span class="op">=&gt;</span> <span class="op">{</span>  
  <span class="kw">const</span> lookupTable <span class="op">=</span> <span class="op">{};</span>

  <span class="cf">return</span> <span class="kw">function</span>(...<span class="at">args</span>) <span class="op">{</span>
    <span class="kw">const</span> key <span class="op">=</span> <span class="va">JSON</span>.<span class="at">stringify</span>(<span class="kw">this</span><span class="op">,</span> args)<span class="op">;</span>

    <span class="cf">return</span> lookupTable[key] <span class="op">||</span> (lookupTable[key] <span class="op">=</span> <span class="va">fn</span>.<span class="at">apply</span>(<span class="kw">this</span><span class="op">,</span> args))<span class="op">;</span>
  <span class="op">}</span>
<span class="op">}</span>
<span class="kw">const</span> memoizedFibonacci <span class="op">=</span> <span class="at">memoized</span>( n <span class="op">=&gt;</span>  
  n <span class="op">&lt;</span> <span class="dv">2</span>
    <span class="op">?</span> n
    : <span class="at">memoizedFibonacci</span>(n<span class="op">-</span><span class="dv">2</span>) <span class="op">+</span> <span class="at">memoizedFibonacci</span>(n<span class="op">-</span><span class="dv">1</span>)
)<span class="op">;</span>
<span class="co">// Benchmarking</span>
(()<span class="op">=&gt;</span> <span class="op">{</span>
  <span class="va">console</span>.<span class="at">time</span>(<span class="st">'before'</span>)<span class="op">;</span>
  <span class="at">fibonacci</span>(<span class="dv">40</span>)<span class="op">;</span>
  <span class="va">console</span>.<span class="at">timeEnd</span>(<span class="st">'before'</span>)<span class="op">;</span>
<span class="op">}</span>)()<span class="op">;</span> <span class="co">// before: 63612.916ms</span>
(()<span class="op">=&gt;</span> <span class="op">{</span>
  <span class="va">console</span>.<span class="at">time</span>(<span class="st">'after'</span>)<span class="op">;</span>
  <span class="at">memoizedFibonacci</span>(<span class="dv">40</span>)<span class="op">;</span>
  <span class="va">console</span>.<span class="at">timeEnd</span>(<span class="st">'after'</span>)<span class="op">;</span>
<span class="op">}</span>)() <span class="co">// after: 0.474ms</span></code></pre></div>
<p>As you can see it takes much less time to obtain the result. By building a cache lookup table, we trade space for time and make our function.</p>
<p>Sometimes, we will want to set a limit on your cache size to prevent occupying too much memory. A naive implementation is as follow</p>
<div class="sourceCode"><pre class="sourceCode js"><code class="sourceCode javascript"><span class="kw">const</span> createCache <span class="op">=</span> limit <span class="op">=&gt;</span> <span class="op">{</span>  
  <span class="kw">const</span> entries <span class="op">=</span> []<span class="op">;</span>

  <span class="kw">function</span> <span class="at">get</span>(key) <span class="op">{</span>
    <span class="cf">for</span> (<span class="kw">let</span> index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> index <span class="op">&lt;</span> <span class="va">entries</span>.<span class="at">length</span><span class="op">;</span> index<span class="op">++</span>) <span class="op">{</span>
      <span class="kw">const</span> entry <span class="op">=</span> entries[index]<span class="op">;</span>
      <span class="cf">if</span> (key <span class="op">===</span> <span class="va">entry</span>.<span class="at">key</span>) <span class="op">{</span>
        <span class="cf">if</span> (index <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">{</span>
          <span class="va">entries</span>.<span class="at">splice</span>(index<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span>
          <span class="va">entries</span>.<span class="at">unshift</span>(entry)<span class="op">;</span>
        <span class="op">}</span>
        <span class="cf">return</span> <span class="va">entry</span>.<span class="at">value</span><span class="op">;</span>
      <span class="op">}</span>
    <span class="op">}</span>
  <span class="op">}</span>

  <span class="kw">function</span> <span class="at">put</span>(key<span class="op">,</span> value) <span class="op">{</span>
    <span class="cf">if</span> (<span class="op">!</span><span class="at">get</span>(key)) <span class="op">{</span>
      <span class="va">entries</span>.<span class="at">unshift</span>(<span class="op">{</span>key<span class="op">,</span> value<span class="op">}</span>)<span class="op">;</span>
      <span class="cf">if</span> (<span class="va">entries</span>.<span class="at">length</span> <span class="op">&gt;</span> limit) <span class="op">{</span>
        <span class="va">entries</span>.<span class="at">pop</span>()<span class="op">;</span>
      <span class="op">}</span>
    <span class="op">}</span>
  <span class="op">}</span>

  <span class="cf">return</span> <span class="op">{</span>get<span class="op">,</span> put<span class="op">};</span>
<span class="op">}</span>

<span class="kw">const</span> memoized <span class="op">=</span> limit <span class="op">=&gt;</span> fn <span class="op">=&gt;</span> <span class="op">{</span>  
  <span class="kw">const</span> cache <span class="op">=</span> <span class="at">createCache</span>(limit)<span class="op">;</span>

  <span class="cf">return</span> <span class="kw">function</span>(...<span class="at">args</span>) <span class="op">{</span>
    <span class="kw">const</span> key <span class="op">=</span> <span class="va">JSON</span>.<span class="at">stringify</span>(<span class="kw">this</span><span class="op">,</span> args)<span class="op">;</span>
    <span class="kw">let</span> value <span class="op">=</span> <span class="va">cache</span>.<span class="at">get</span>(key)<span class="op">;</span>
    <span class="cf">if</span> (<span class="op">!</span>value) <span class="op">{</span>
      value <span class="op">=</span> <span class="va">fn</span>.<span class="at">apply</span>(<span class="kw">this</span><span class="op">,</span> args)
    <span class="op">}</span>
    <span class="va">cache</span>.<span class="at">put</span>(key<span class="op">,</span> value)<span class="op">;</span>
    <span class="cf">return</span> value<span class="op">;</span>
  <span class="op">}</span>
<span class="op">}</span>

<span class="co">// memoized result of latest 10 arguments</span>
<span class="kw">const</span> memoizedFibonacci <span class="op">=</span> <span class="at">memoized</span>(<span class="dv">10</span>)( n <span class="op">=&gt;</span>  
  n <span class="op">&lt;</span> <span class="dv">2</span>
    <span class="op">?</span> n
    : <span class="at">memoizedFibonacci</span>(n<span class="op">-</span><span class="dv">2</span>) <span class="op">+</span> <span class="at">memoizedFibonacci</span>(n<span class="op">-</span><span class="dv">1</span>)
)<span class="op">;</span></code></pre></div>
<p>One of the use case in web application will be like some complex form validation. Please note that the above function heavily using closure in javascript. If you are not familiar with closure, you might want to have a look at the post I previously written <a href="understanding-javascript-closure.html">here</a>.</p>
  </div>
  
  <hr>
  <div class="disqus__block">
  <div id="disqus_thread"></div>
  <script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = 'https://swtpain.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

  
</article>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-102897942-1', 'auto');
      ga('send', 'pageview');

    </script>
    <script id="dsq-count-scr" src="//swtpain.disqus.com/count.js" async></script>
</html>
