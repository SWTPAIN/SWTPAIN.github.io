<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta property="og:site_name" content="KaFai Choi">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Learn Elixir - Writing a weightlifting tracking server - part 2 - Let it crash">
    <meta property="og:image" content>
    <meta property="og:url" content="https://bruteforcecat.github.io/posts/learn-elixir-writing-weightlifting-tracking-server-part-2-let-it-crash.html">
    <meta property="og:description" content="Learn Elixir - Writing a weightlifting tracking server - part 2 - Let it crash">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="KaFai Choi">
    <meta name="description" content="Learn Elixir - Writing a weightlifting tracking server - part 2 - Let it crash">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="../css/default.css">
    <link rel="stylesheet" type="text/css" href="../css/pandoc.css">
    <link rel="alternate" type="application/rss+xml" href="../rss.xml" title="RSS">
    <script>try{Typekit.load({ async: true });}catch(e){}</script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js"></script>
    <title>Learn Elixir - Writing a weightlifting tracking server - part 2 - Let it crash</title>
  </head>
  <body>
    <nav class="navigation">
      <ul class="navigation__list">
        <li class="navigation__item">
          <a class="header__link" href="../">
            Y = λf.(λx.f(xx))(λx.f(xx))
          </a>
        </li>
      </ul>
    </nav>
    
    <article>
  <div class="article__infoContainer">
    <div class="article__info">
      <p class="article__title">
         Learn Elixir - Writing a weightlifting tracking server - part 2 - Let it crash
      </p>
      <time class="article__date">August 14, 2017</time>
    </div>
  </div>
  <div class="article__content">
    <h2 id="intro">Intro</h2>
<p>In part 1, we have used the basic concurrency primitives, processes, to build our naive weightlifting tracking server. And in this part 2, we are going to use OTP framework provided by Erlang to build a more reliable system with simpler codes. And we will also add a web server to our system to let other call our system through http request.</p>
<h2 id="project-setup">Project Setup</h2>
<p>Repo is <a href="https://github.com/bruteforcecat/strong-as-fuck">here</a>. To see the source code:</p>
<pre><code>git clone git@github.com:bruteforcecat/strong-as-fuck.git
cd strong-as-fuck
git checkout v0.0.2</code></pre>
<h2 id="application">Application</h2>
<p>An application in a component that can be started and stopped as a unit. In our weightlifting tracking application, we will have server supervisors, database supervisors and web server. By using application, we could easily start and stop entire system.</p>
<div class="sourceCode"><pre class="sourceCode elixir"><code class="sourceCode elixir"><span class="co"># mix.ex</span>
<span class="kw">defmodule</span> <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">Mixfile</span> <span class="kw">do</span>
  <span class="im">use</span> <span class="cn">Mix</span><span class="op">.</span><span class="cn">Project</span>

  <span class="co"># ...</span>
  <span class="kw">def</span> application <span class="kw">do</span>
    [
      <span class="va">extra_applications:</span> [<span class="va">:logger</span>, <span class="va">:poolboy</span>],
      <span class="va">mod:</span> {<span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">Application</span>, []}
    ]
  <span class="kw">end</span>
<span class="kw">end</span>

<span class="co"># lib/strong_as_fuck/application.ex</span>
<span class="kw">defmodule</span> <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">Application</span> <span class="kw">do</span>
  <span class="im">use</span> <span class="cn">Application</span>

  <span class="kw">def</span> start(_type, _args) <span class="kw">do</span>
    response <span class="op">=</span> <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">Supervisor</span><span class="op">.</span>start_link
    <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">Web</span><span class="op">.</span>start_server
    response
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<p><code>mod: {StrongAsFuck.Application, []}</code> specific that <code>StrongAsFuck.Application</code> will be our application callback module which means StrongAsFuck.Application will start our application supervision tree. And we will start our application supervisor and web server there.</p>
<h2 id="web-server">Web Server</h2>
<p>Instead of using the hottest web framework Phoenix, we would use a much lighter web framework called Cowboy(which is actually used in Phoenix) together with Plug which is like Rack in Ruby, providing a specification of composable module for writing web application.</p>
<div class="sourceCode"><pre class="sourceCode elixir"><code class="sourceCode elixir"><span class="kw">defmodule</span> <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">Web</span> <span class="kw">do</span>
  <span class="im">use</span> <span class="cn">Plug</span><span class="op">.</span><span class="cn">Router</span>

  plug <span class="va">:match</span>
  plug <span class="va">:dispatch</span>

  <span class="kw">def</span> start_server <span class="kw">do</span>
    <span class="cn">Plug</span><span class="op">.</span><span class="cn">Adapters</span><span class="op">.</span><span class="cn">Cowboy</span><span class="op">.</span>http(__MODULE__, <span class="cn">nil</span>, <span class="va">port:</span> <span class="dv">4000</span>)
  <span class="kw">end</span>

  get <span class="st">&quot;/training_log_books/:username&quot;</span> <span class="kw">do</span>
    conn
    <span class="op">|&gt;</span> <span class="cn">Plug</span><span class="op">.</span><span class="cn">Conn</span><span class="op">.</span>fetch_query_params
    <span class="op">|&gt;</span> fetch_notebook
    <span class="op">|&gt;</span> respond
  <span class="kw">end</span>

  post <span class="st">&quot;/training_log_books/:username/training_logs&quot;</span> <span class="kw">do</span>
    conn
    <span class="op">|&gt;</span> <span class="cn">Plug</span><span class="op">.</span><span class="cn">Conn</span><span class="op">.</span>fetch_query_params
    <span class="op">|&gt;</span> add_training_log
    <span class="op">|&gt;</span> respond
  <span class="kw">end</span>
  <span class="co"># ...</span>
  <span class="kw">defp</span> respond(conn) <span class="kw">do</span>
    conn
    <span class="op">|&gt;</span> <span class="cn">Plug</span><span class="op">.</span><span class="cn">Conn</span><span class="op">.</span>put_resp_content_type(<span class="st">&quot;application/json&quot;</span>)
    <span class="op">|&gt;</span> <span class="cn">Plug</span><span class="op">.</span><span class="cn">Conn</span><span class="op">.</span>send_resp(<span class="dv">200</span>, conn<span class="op">.</span>assigns[<span class="va">:response</span>])
  <span class="kw">end</span>

<span class="kw">end</span></code></pre></div>
<p>The only function exposed in StrongAsFuck.Web is <code>start_server</code>. You can see plug doesn’t provide http server instead it is adapter for different web servers and here we use Cowboy.</p>
<p>We use <code>Plug.Router</code> which give us marco like <code>get</code> and <code>post</code> so we can match incoming request and perform desired action. The specification is that we will have a connection which is just a <code>Struct</code> in elixir and return a new connection with response field populated.</p>
<h2 id="otp">OTP</h2>
<h3 id="generic-server">Generic Server</h3>
<p>Previously in part 1, we used recursive function call <code>loop</code> to keep server process alive and have to pass <code>self()</code> and call <code>receive</code> in order to wait for message sent back to caller process.</p>
<p>In OTP, we have GenServer behavior you can think of its an abstraction of the common client-server interaction. To use this, we will call <code>use GenServer</code> macro and implement required callbacks which are <code>&amp;init/1</code> which will return initial state and allow us to run some initialization work, <code>&amp;handle_call/3</code> and <code>GenServer.cast</code> for handling synchronous <code>GenServer.call</code> and asynchronous <code>GenServer.cast</code>.</p>
<div class="sourceCode"><pre class="sourceCode elixir"><code class="sourceCode elixir"><span class="kw">defmodule</span> <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">Server</span> <span class="kw">do</span>
  <span class="im">use</span> <span class="cn">GenServer</span>

  <span class="im">alias</span> <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">TrainingLogBook</span>, <span class="va">as:</span> <span class="cn">TrainingLogBook</span>

  <span class="kw">def</span> start_link(username) <span class="kw">do</span>
    <span class="cn">IO</span><span class="op">.</span>puts <span class="st">&quot;Starting </span><span class="ot">#{</span>__MODULE__<span class="ot">}</span><span class="st"> from </span><span class="ot">#{</span>username<span class="ot">}</span><span class="st">&quot;</span>
    <span class="cn">GenServer</span><span class="op">.</span>start_link(
      <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">Server</span>,
      username,
      <span class="va">name:</span> via_tuple(username)
    )
  <span class="kw">end</span>
  <span class="co"># ...</span>
  <span class="kw">def</span> init(username) <span class="kw">do</span>
    {<span class="va">:ok</span>, {username, get_initial_state(username)}}
  <span class="kw">end</span>

  <span class="kw">def</span> handle_call(
    {<span class="va">:add_training_log</span>, new_training_log},
    _,
    {username, trainig_log_book}
  ) <span class="kw">do</span>
    <span class="kw">case</span> <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">TrainingLogBook</span><span class="op">.</span>add_log(trainig_log_book, new_training_log) <span class="kw">do</span>
      {<span class="va">:ok</span>, new_training_log_book} <span class="op">-&gt;</span>
        <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">Database</span><span class="op">.</span>insert(username, new_training_log_book)
        {<span class="va">:reply</span>, <span class="va">:ok</span>, {username, new_training_log_book}}
      {<span class="va">:error</span>, err_msg} <span class="op">-&gt;</span>
        {<span class="va">:reply</span>, {<span class="va">:error</span>, err_msg}, {username, trainig_log_book}}
    <span class="kw">end</span>
  <span class="kw">end</span>

  <span class="kw">def</span> handle_call(
    {<span class="va">:get_notebook</span>},
    _,
    {username, trainig_log_book}
  ) <span class="kw">do</span>
    <span class="kw">case</span> <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">Database</span><span class="op">.</span>get(username) <span class="kw">do</span>
      <span class="cn">nil</span> <span class="op">-&gt;</span>
        {<span class="va">:reply</span>, {<span class="va">:error</span>, <span class="st">&quot;no training log book with username: </span><span class="ot">#{</span>username<span class="ot">}</span><span class="st">&quot;</span>}, {username, trainig_log_book}}
      new_training_log_book <span class="op">-&gt;</span>
        {<span class="va">:reply</span>, {<span class="va">:ok</span>, new_training_log_book}, {username, new_training_log_book}}
    <span class="kw">end</span>
  <span class="kw">end</span>
  <span class="co"># ...</span></code></pre></div>
<p>The difference between the <code>GenServer.call</code> and <code>GenServer.cast</code> is that <code>GenServer.call</code> will block the caller process until the function <code>handle_call</code> return while <code>GenServer.cast</code> is basically fire and forget.</p>
<h3 id="supervisor">Supervisor</h3>
<p>In order to make our system more responsive, we want to have a separate server process concurrently for each user training log book so no user process will be blocked by others. But what if one process crash?</p>
<p>Instead of writing lots of defensive code like <code>try catch</code> block, we will need another process called supervisor to monitor the rest of the children(worker) processes. When a worker termintes, the supervisor will start another one and replace it.</p>
<div class="sourceCode"><pre class="sourceCode elixir"><code class="sourceCode elixir"><span class="kw">defmodule</span> <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">ServerSupervisor</span> <span class="kw">do</span>
  <span class="im">use</span> <span class="cn">Supervisor</span>

  <span class="kw">def</span> start_link <span class="kw">do</span>
    <span class="cn">Supervisor</span><span class="op">.</span>start_link(__MODULE__, <span class="cn">nil</span>, <span class="va">name:</span> <span class="va">:strong_as_fuck_server_supervisor</span>)
  <span class="kw">end</span>

  <span class="kw">def</span> start_child(username) <span class="kw">do</span>
    <span class="cn">Supervisor</span><span class="op">.</span>start_child(<span class="va">:strong_as_fuck_server_supervisor</span>, [username])
  <span class="kw">end</span>

  <span class="kw">def</span> init(_args) <span class="kw">do</span>
    children <span class="op">=</span> [
      worker(<span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">Server</span>, [])
    ]
    supervise(children, <span class="va">strategy:</span> <span class="va">:simple_one_for_one</span>)
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<p>And we will use <code>simple_one_for_one</code> strategy because all child process are dynamically created.</p>
<h3 id="process-registry">Process Registry</h3>
<div class="sourceCode"><pre class="sourceCode elixir"><code class="sourceCode elixir"><span class="kw">defmodule</span> <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">Cache</span> <span class="kw">do</span>

  <span class="kw">def</span> server_process(username) <span class="kw">do</span>
    <span class="kw">case</span> <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">Server</span><span class="op">.</span>whereis(username) <span class="kw">do</span>
      <span class="va">:undefined</span> <span class="op">-&gt;</span>
        create_server(username)
      pid <span class="op">-&gt;</span>
        pid
    <span class="kw">end</span>
  <span class="kw">end</span>

  <span class="kw">defp</span> create_server(username) <span class="kw">do</span>
    <span class="kw">case</span> <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">ServerSupervisor</span><span class="op">.</span>start_child(username) <span class="kw">do</span>
      {<span class="va">:ok</span>, pid} <span class="op">-&gt;</span> pid
      {<span class="va">:error</span>, {<span class="va">:already_started</span>, pid}} <span class="op">-&gt;</span> pid
    <span class="kw">end</span>
  <span class="kw">end</span>

<span class="kw">end</span></code></pre></div>
<p>But how do we know which server process to use for any given user. To solve this, we will need process registry which basically persist mapping of pid to username. Here, we use <code>gproc</code> as the process registry library. The logic is very simple. If we find an existing process by username, we will return the pid of that process. If no, we will create a new <code>StrongAsFuck.Server</code> process and return the pid.</p>
<h3 id="database">Database</h3>
<p>We will use <code>mnesia</code> for our database due to its simplicity. For database, we want to have a pool of fixed number of workers which will be supervised by <code>StrongAsFuck.Database</code>. The simple implementation of pooling is starting worker process and forward request to worker based on some routing logic. Here we will use <code>poolboy</code>. By providing pool name in <code>:poolboy.transaction</code>, and we will have the available worker pid in our callback function.</p>
<div class="sourceCode"><pre class="sourceCode elixir"><code class="sourceCode elixir"><span class="co"># lib/strong_as_fuck/database_supervisor.ex</span>
<span class="kw">defmodule</span> <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">DatabaseSupervisor</span> <span class="kw">do</span>

  <span class="kw">def</span> start_link(pool_size) <span class="kw">do</span>
    children <span class="op">=</span> [
      <span class="va">:poolboy</span><span class="op">.</span>child_spec(<span class="va">:worker</span>, poolboy_config(pool_size), [])
    ]
    <span class="cn">Supervisor</span><span class="op">.</span>start_link(children, <span class="va">strategy:</span> <span class="va">:one_for_one</span>)
  <span class="kw">end</span>

  <span class="kw">defp</span> poolboy_config(pool_size) <span class="kw">do</span>
    [
      {<span class="va">:name</span>, {<span class="va">:local</span>, pool_name()}},
      {<span class="va">:worker_module</span>, <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">DatabaseWorker</span>},
      {<span class="va">:size</span>, pool_size},
      {<span class="va">:max_overflow</span>, <span class="dv">2</span>}
    ]
  <span class="kw">end</span>

  <span class="kw">def</span> pool_name(), <span class="kw">do</span>: <span class="va">:strong_as_fuck_database_worker_pool</span>

<span class="kw">end</span>

<span class="co"># lib/strong_as_fuck/database.ex</span>
<span class="kw">defmodule</span> <span class="cn">StrongAsFuck</span><span class="op">.</span><span class="cn">Database</span> <span class="kw">do</span>

  <span class="co"># ...</span>
  <span class="kw">def</span> start_link() <span class="kw">do</span>
    <span class="co"># ...</span>
    <span class="va">:mnesia</span><span class="op">.</span>start

    <span class="cn">DatabaseSupervisor</span><span class="op">.</span>start_link(<span class="ot">@pool_size</span>)
  <span class="kw">end</span>

  <span class="kw">def</span> insert(key, data) <span class="kw">do</span>
    <span class="va">:poolboy</span><span class="op">.</span>transaction(
      <span class="cn">DatabaseSupervisor</span><span class="op">.</span>pool_name(),
      <span class="kw">fn</span>(pid) <span class="op">-&gt;</span>
        <span class="cn">GenServer</span><span class="op">.</span>call(pid, {<span class="va">:insert</span>, key, data})
      <span class="kw">end</span>,
      <span class="ot">@worker_timeout</span>
    )
  <span class="kw">end</span>

  <span class="kw">def</span> get(key) <span class="kw">do</span>
    <span class="va">:poolboy</span><span class="op">.</span>transaction(
      <span class="cn">DatabaseSupervisor</span><span class="op">.</span>pool_name(),
      <span class="kw">fn</span>(pid) <span class="op">-&gt;</span>
        <span class="cn">GenServer</span><span class="op">.</span>call(pid, {<span class="va">:get</span>, key})
      <span class="kw">end</span>,
      <span class="ot">@worker_timeout</span>
    )
  <span class="kw">end</span>
<span class="kw">end</span></code></pre></div>
<h2 id="play-with-it-in-iex">Play with it in Iex</h2>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash"><span class="ex">iex</span> -S mix
<span class="co"># another shell</span>
<span class="ex">curl</span> -d <span class="st">''</span> <span class="st">'http://localhost:4000/training_log_books/alice/training_logs?movement_name=snatch&amp;rep=10&amp;weight=100'</span>
<span class="co"># OK</span>
<span class="ex">curl</span> http://localhost:4000/training_log_books/alice
<span class="co"># {&quot;username&quot;:&quot;alice&quot;,&quot;logs&quot;:[{&quot;weight&quot;:&quot;100&quot;,&quot;rep&quot;:&quot;10&quot;,&quot;movement_name&quot;:&quot;snatch&quot;}]}%</span></code></pre></div>
<p>We can easily application process tree by <code>:observer.start</code> in iex. <img src="../images/erlang-process.png" alt="erlang process tree" /></p>
<p>Now our weightlifting tracking server can be accessed through http interface and we have use OTP to make sure our system is responsive and fault-tolerated. The next part will be using <code>Phoenix</code> web framework and implement more feature!</p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://www.amazon.com/Little-Elixir-OTP-Guidebook/dp/1633430111/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1502723740&amp;sr=1-2&amp;keywords=elixir">The Little Elixir &amp; OTP Guidebook</a></li>
<li><a href="https://www.amazon.com/Programming-Elixir-1-3-Functional-Concurrent/dp/168050200X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1502723740&amp;sr=1-1&amp;keywords=elixir">Programming Elixir 1.3: Functional |&gt; Concurrent |&gt; Pragmatic |&gt; Fun</a></li>
<li><a href="https://www.amazon.com/Elixir-Action-Sa%C5%A1a-Juri-cacute/dp/161729201X/ref=sr_1_4?s=books&amp;ie=UTF8&amp;qid=1502723740&amp;sr=1-4&amp;keywords=elixir">Elixir in Action</a></li>
</ul>
  </div>
  
  <hr>
  <div class="disqus__block">
  <div id="disqus_thread"></div>
  <script>
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = 'https://swtpain.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

  
</article>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-102897942-1', 'auto');
      ga('send', 'pageview');

    </script>
    <script id="dsq-count-scr" src="//swtpain.disqus.com/count.js" async></script>
</html>
